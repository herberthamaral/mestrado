\documentclass[11pt]{article}
\usepackage{mathtools}
\usepackage{epsfig,psfrag}
\usepackage{listings}
\usepackage{color}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage{lipsum} % Package to generate dummy text throughout this template
\usepackage[brazil]{babel}
\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[utf8]{inputenc}
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics
\usepackage{algpseudocode}
\usepackage{algorithmicx}

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\selectlanguage{brazil}

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{{\vspace{-3cm}{\hspace{-4cm}\mbox{\begin{minipage}{1.5cm} \epsfxsize=2cm
\centerline{\epsffile{unimontes.eps}}
\end{minipage}}}{\hspace{.6cm} Projeto e Análise de Algoritmos $\bullet$ 2015}}
} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text




%----------------------------------------------------------------------------------------
%    TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{.5cm}\fontsize{24pt}{10pt}\selectfont\textbf{\sc Lista de Exercícios - Complexidade de problemas}} % Article title

\author{
\large
\textsc{Herberth Amaral}\\[2mm] % Your name
\normalsize Departamento de Ciência da Computação \\
\normalsize Universidade Estadual de Montes Claros \\
\normalsize \href{mailto:herberthamaral@gmail.com}{herberthamaral@gmail.com} % Your email address
\vspace{-5mm}
}
\date{\today}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%    ABSTRACT
%----------------------------------------------------------------------------------------
%\begin{abstract}
%\noindent O presente trabalho analisa o uso de redes neurais artificiais do
%tipo perceptron de múltiplas camadas para fazer classificação de dados de
%comparação de registros, a fim de categorizá-los como registros correspondentes
%ou não-correspondentes, em um processo conhecido como record linkage.  A base
%de dados contém os resultados de comparação de dados demográficos provenientes
%do registro epidemiológico de câncer do estado alemão de Rhine-Westphalia \cite{west}.
%Os resultados mostram que a rede neural usada neste trabalho conseguiu
%classificar os registros satisfatoriamente.
%
%
%\end{abstract}

\newpage

\section*{Exercícios}

\begin{enumerate}
    \item Problemas da classe NP-Completo estão dentro de NP, que podem ser
        resolvidos em tempo exponencial, portanto a afirmativa é verdadeira. No
        entanto, vale observar que não se sabe se os problemas NP podem ser
        resolvidos \textit{somente} em tempo exponencial.
    \item
        \begin{enumerate}
            \item P = problemas computáveis em tempo polinomial por uma máquina de Turing;
            \item NP = problemas computáveis em tempo polinomial por uma máquina não-determinística ("oráculo");
            \item NP-Completo = problemas dentro da classe NP e da classe NP-hard.
        \end{enumerate}
    \item
        \begin{enumerate}
            \item Problemas de decisão são aqueles que precisam de respostas
                "sim" ou "não". Exemplo: há uma rota de Montes Claros e BH que
                não passe por Bocaíuva? Os problemas de otimização são aqueles
                que visam em encontrar uma solução de menor custo. Exemplo:
                qual é a melhor rota daqui para São Paulo?
            \item Um problema NP-Completo é um problema que é ao mesmo tempo NP
                e NP-difícil. Portanto as duas pessoas estão corretas, mas a
                pessoa que disse que é NP-Completo possui uma resposta mais
                específica.
            \item NSPACE é uma categoria de problemas que tem complexidade de
                espaço (memória) polinomial em uma máquina não-determinística.
                Problemas de planejamento são NPSPACE.
            \item Um problema é dito estar na classe CO-NP se o seu complemento
                está em NP. Note que é possível problemas cujos complementos
                sejam eles mesmos e por isso eles podem estar em CO-NP e em NP
                ao mesmo tempo. Um exemplo de problema CO-NP é o problema da
                fatoração de inteiros.
            \item O problema das Torres de Hanoi possui complexidade
                $\Omega(2^n)$. Desta forma é impossível achar um algoritmo em
                tempo polinomial para resolver o problema das torres de Hanoi.
                Não se sabe se os problemas da classe NP-Completo podem ser
                reduzidos para tempo polinomial, portanto o problema das torres
                de Hanoi não se encaixa em NP-Completo.
        \end{enumerate}
    \item
        \begin{enumerate}
            \item Dado o conjunto F de todas as funções existentes. Existem
                funções criadas a partir de combinações de $n$ outras funções
                ($n > 1$). Desta forma há funções incontáveis que não se sabe
                determinar sua saída a partir de sua entrada.
            \item O problema da parada é um problema indecidível porque não é
                possível criar um programa que decida que outro programa pare
                para uma determinada entrada.
        \end{enumerate}
    \item Tanto faz. A redução de um programa NP-completo em tempo polinomial a
        outro sempre será NP-completo.
    \item Talvez.
    \item Mesma coisa da questão 5: se um problema é NP-completo e é redutível
        a outro problma $B$ em tempo polinomial, então $B \in NP-completo$.
    \item
        \begin{enumerate}
            \item Pode-se usar um algoritmo de ordenação por contagem e reduzir
                o pareamento a ele da mesma forma que é demonstrado no livro na
                seção 17.1
            \item Não. O problema do pareamento é redutível ao problema de
                ordenação, porém o inverso não é verdadeiro. Por mais que
                achemos soluções menos complexas que $\Omega(nlogn)$ para
                pareamento, não significa que podemos aplicar essas soluções
                para ordenação por comparação.
        \end{enumerate}
    \item \textbf{Prova que 3-coloração é NP-Completo:} Dado que 3-SAT é
        NP-Completo, podemos reduzi-lo à 3-Coloração de um grafo $G$ através de
        um processo polinomial que toma um conjunto de subgrafos de $G$ com 3
        vértices e o submete ao teste de satisfabilidade do 3-SAT. Desta forma
        é possível reduzir o problema de 3-Coloração à 3-SAT. No entanto, uma
        redução de um problema NP-Completo em tempo polinomial só pode ser
        NP-Completo. Portanto 3-coloração é NP-Completo. \textbf{Prova que
        k-coloração é NP-Completo}: É possível provar por indução matemática
        que k-coloração é NP completo se assumirmos que podemos reduzir
        k-coloração à k-SAT para $k>2$, que é conhecidamente NP-Completo.
    \item Pelo teorema mostrado no exemplo 17.3 do livro, o algoritmo K-Clique
        é NP-completo. Se for possível provar que o K-Clique executa em tempo
        polinomial, então poderemos ter reduções de problemas NP-Completo ao
        K-Clique em tempo polinomial de forma que fique provado que P=NP.
    \item 11
    \item O problema de decisão do caixeiro viajante pode ser reduzido ao
        problema de encontrar a melhor rota para o caixeiro viajante em tempo
        polinomial. Basta pedirmos a melhor rota para o problema de otimização
        do caixeiro viajante, se ela existir então o problema de decisão
        retorna "Sim", caso contrário o problema de decisão retorna "não".
        Desta forma, como um problema NP-completo reduzido a um tempo
        polinomial também será NP-Completo (pois caso contrário prova-se que
        P=NP), então o problema de decisão do caixeiro viajante é NP-Completo.
    \item Para provar que um problema é NP-completo, é necessário mostrar que é
        NP e que é NP-hard. \textbf{Prova que é NP:} Podemos simplesmente
        adivinhar se a saída será sim ou não e verificar em tempo polinominal.
        \textbf{Prova que é NP-Hard:} para esta prova precisamos reduzir o
        problema INDEPENDENT SET a um problema NP-Hard (no caso, o K-Clique).
        Para tal, é necessário fazer a conversão das entradas. O INDEPENDENT
        SET retorna "sim" se \textit{existe um subconjunto de vértices
        \textbf{S} de um grafo \textbf{G} de tamanho $k$ ou maior de forma que
    não há nenhuma aresta que conecta dois vértices em \textbf{S}} e retorna
    "não" caso contrário. Portanto, é necessário encontrar o complemento das
    arestas de forma que os vértices que não tem nenhuma ligação passem a ser
    um clique. Após esse procedimento, podemos executar o algoritmo $K-Clique$
    para verificar identificar um clique de tamanho $\geq n$. Caso haja um
    clique com tal característica, o INDEPENDENT SET pode retornar "sim". Caso
    contrário retorna "não".
    \item 14
    \item Dado o conjunto C de todas as sequencias binárias existentes. Sempre
        existirá uma sequencia feita pela diagonalização de todas as sequencias
        que será diferente de todas as outras e, desta forma, não será contada.
        Portanto, a sequencia de todos os numeros binarios é incontável.
    \item \textbf{Prova por indução:} Considere a seguinte lista de números racionais: \\
        $\displaystyle \frac 0 1, \frac 1 1, \frac {-1} 1, \frac 1 2, \frac {-1} 2, \frac 2 1, \frac {-2} 1, \frac 1 3, \frac 2 3, \frac {-1} 3, \frac {-2} 3, \frac 3 1, \frac 3 2, \frac {-3} 1, \frac {-3} 2, \frac 1 4, \frac 3 4, \frac {-1} 4, \frac {-3} 4, \frac 4 1, \frac 4 3, \frac {-4} 1, \frac {-4} 3 \ldots$ \\
        É claro que todos os números racionais irão aparecer nesta lista. Desta
        forma é possível enumerar cada um dos elementos da lista acima.
    \item \textbf{Prova por absurdo}. Sabendo que o problema da parada é
        insolúvel, podemos provar que tal programa é insolúvel através de uma
        redução do problema da impressão para o problema da parada. Dado uma
        função $ImprimeAlgumaCoisa(programa, entrada)$, que retorna "sim" ou
        "não" podemos definir o problema da parada da seguinte forma:
        $ProgramaPara(programa, entrada) ->
        ImprimeAlgumaCoisa(RemovePrints(programa) + "print 'alguma coisa'", entrada))$.
        Como sabemos que o problema da parada é indecidível e que conseguimos
        reduzi-lo ao programa de $ImprimeAlgumaCoisa$, então é absurdo afirmar
        que $ImprimeAlgumaCoisa$ é indecidível.
    \item Mesmo caso do item anterior: dado uma instrução $x$, vamos assumir
        que exista um programa $ExecutaX(programa, entrada)$ que responde sim
        ou não. Podemos reduzir esse problema ao problema da parada que sabemos
        que é insolúvel. E podemos fazer isso desta forma:
        $ProgramaPara(programa, entrada) -> ExecutaX(RemoveInstrucoesX(programa)+x, entrada)$.
        Desta forma, se o ExecutaX retornar "sim" ou "não", então o problema da
        parada estará resolvido, o que é absurdo.
\end{enumerate}

%\begin{thebibliography}{1}
%    \bibitem{thorup}
%    M. Thorup, Undirected single-source shortest paths with positive integer
%weights in linear time {\em JACM} {\bf 46} (1999).  \end{thebibliography}

\end{document}
